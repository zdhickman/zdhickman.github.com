{"body":"`A leafy binary tree is a binary tree with the symbol 'leaf at its leafs.\r\n\r\nDesign a function that consumes a natural number n and creates (a list of) all leafy binary trees of height n.\r\n\r\nHint: Design a function that consumes a natural number n and creates (a list of) all leafy binary trees of height equal or less than n.`\r\n\r\nThis was a problem in my Fundamentals of Computer Science class that a lot of people struggled with. Here is the step-by-step on solving this problem. Note that the height means the length of the longest branch in the binary tree.\r\n\r\nBased on the recommendation within the problem, we will first be designing a function that generates trees with the heights less than or equal to the given n. It should also be noted that each node is required to have two branches extending from it.\r\n\r\nThe first step was figuring out the pattern, or algorithm, to this problem. If you took out a whiteboard and drew out the result for height(1, 2, 3), you can notice a striking pattern. Put simply, the results of n can be made by taking the results of n-1, and combining each result with every other result, including itself, underneath a common node.\r\n\r\nAn example of this is shown when finding all binary trees of height less than or equal to 2. We start at our base case, which would be when 0 is input, since our function must deal with all natural numbers. A height of 0 means no branches exist, and since we determine the node itself must have two branches, the only option for height 0 must be a single leaf. Given that the answer must be in a list, the resulting list would be (list ‘leaf).\r\n\r\nAccording to the pattern previously described, if we took every combination in this list, there would only be one combination: a ‘leaf and a ‘leaf. Inserting this under a common node results in: (make-node ‘leaf ‘leaf). And, of course, we still have our base case result for 0, resulting in a final list: (list (make-node ‘leaf ‘leaf) ‘leaf).\r\n\r\nFinally, we will use this result list to generate all trees with heights less than or equal to 2. Our resulting list is as follows:\r\n\r\n`(list (make-node (make-node ‘leaf ‘leaf) (make-node ‘leaf ‘leaf)) (make-node (make-node ‘leaf ‘leaf) ‘leaf) (make-node ‘leaf (make-node ‘leaf ‘leaf)) (make-node ‘leaf ‘leaf) ‘leaf)`\r\n\r\nThis pattern can be applied recursively to generate trees of any height. So: how do we code this?\r\n\r\nLet’s start by defining our node-struct:\r\n\r\n`(define-struct node (left right))`\r\n\r\nNext, we have to critically think of how to apply each member of a list to a make-node with every other member of the list, including itself. We have some functions that we can use that deal with lists. In this case, I decided to use map. Let’s start by using the map function to put each member of the list into one branch of the make-node.\r\n\r\n`(map (lambda (tree-right)\r\n(make-node ???? tree-right)\r\nour-trees)`\r\n\r\nWhat does this do? We are using our anonymous function which takes each member of the our-trees list (which will be explained in a second), and sticks it into a make-node along with….something else. What is this something else? Well, it’s the list, again. So, let’s use map; again!\r\n\r\n`(map (lambda (tree-left)\r\n(map (lambda (tree-right)\r\n(make-node tree-left tree-right)\r\nour-trees))\r\nour-trees))`\r\n\r\nEvery time the inner loop creates a set of make-nodes for each member of our list, the outer loop will add a member of the list into the node. This repeats until every combination is created.\r\n\r\nWe still haven’t defined our-trees yet, but we’ll get to that later.\r\n\r\nTechnically, our function right now creates a lot of lists. We want one list. How can we accumulate our lists into one large list? Why not foldr?\r\n\r\n`(foldr append\r\n(list ‘leaf)\r\n(map (lambda (tree-left)\r\n(map (lambda (tree-right)\r\n(make-node tree-left tree-right)\r\nour-trees))\r\nour-trees)))`\r\n\r\nWe’re almost done! This code tells use that we want to use append on each list, recursively adding them to one large list until we reach our base case, which sticks a ‘leaf in on the end.\r\n\r\nOnly two things are left:\r\n\r\nfigure out what our-trees is, and\r\ndeal with our base case when we build our actual function.\r\nRemember that when we figured out our initial algorithm, we decided that trees less than or equal to height n were made from the trees less than or equal to height n-1. Therefore, our-trees is the result of passing our function n-1 instead of n. Recursion! Let’s use a local function:\r\n\r\n`(local [(define our-trees (gen-all-trees (sub1 n)))]\r\n(foldr append\r\n(list ‘leaf)\r\n(map (lambda (tree-left)\r\n(map (lambda (tree-right)\r\n(make-node tree-left tree-right)\r\nour-trees))\r\nour-trees))))`\r\n\r\nI decided to name our overall function gen-all-trees, and our-trees calls this function with one less than the original input.\r\n\r\nWe’re almost done! What about our base case of 0? It just returns (list ‘leaf), and our recursion has to end somewhere. Let’s finish this function.\r\n\r\n`(define (gen-all-trees n)\r\n(cond\r\n[(= 0 n) (list 'leaf)]\r\n[else    (local [(define our-trees (gen-all-trees (sub1 n)))]\r\n(foldr append\r\n(list ‘leaf)\r\n(map (lambda (tree-left)\r\n(map (lambda (tree-right)\r\n(make-node tree-left tree-right)\r\nour-trees))\r\nour-trees))))]))`\r\n\r\nFinally, we need our actual answer: trees with heights equal to n. We just need to run a filter based on the height of the tree (an easy function to write: find the longest branch!).","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Zdhickman","google":"","tagline":"My Blog"}